%\VignetteIndexEntry{EBImage image processing}
%\VignetteDepends{}
%\VignetteKeywords{image processing}
%\VignettePackage{EBImage}


\documentclass[11pt]{article}
\usepackage{color}
\definecolor{darkblue}{rgb}{0.0,0.0,0.75}
\usepackage[%
baseurl={http://www.ebi.ac.uk/~osklyar/projects/EBImage/},%
pdftitle={EBImage - Image Processing Toolkit For R},%
pdfauthor={Oleg Sklyar},%
pdfsubject={EBImage},%
pdfkeywords={image processing},%
pagebackref,bookmarks,colorlinks,linkcolor=darkblue,citecolor=darkblue,%
pagecolor=darkblue,raiselinks,plainpages,pdftex]{hyperref}

\newcommand{\code}[1]{{\tt #1}}
\newcommand{\func}[1]{{\it #1}}
\newcommand{\file}[1]{{\tt #1}}
\newcommand{\pack}[1]{{\it #1}}
\newcommand{\Rclass}[1]{{\it #1}}

\newcommand{\ebimage}{{\it EBImage}}
\newcommand{\magick}{{\it ImageMagick}}
\newcommand{\R}{{\it R}}
\newcommand{\image}{{\tt Image2D}}

\begin{document}

%------------------------------------------------------------
\title{EBImage - Image Processing Toolkit For R}

\begin{figure}[tp]
    \begin{center}
        \includegraphics[width=60mm]{logo.jpg}
    \end{center}
\end{figure}

%------------------------------------------------------------
\author{Oleg Sklyar}
\maketitle

%--------------------------------------------------
\section{Introduction}
%--------------------------------------------------
\ebimage\ is an image processing and analysis package for \R. The primary goal of the package is to enable automated or semiautomated analysis of large sets of images, e.g. results of automated microscopy screens.

Many of \ebimage\ routines are based on the \magick\ C++ library
(\pack{Magick++}) that provides all I/O operations as well as some
filter routines. The package currently does not expose all functions
of \magick, it concentrates on those that are essential and usefull
for data analysis, and it neglects functions e.\,g.\ for image
enhancing and restoration.  On top of \magick\ further routines and
algorithms are implemented to support \emph{distance maps},
\emph{thresholding}, \emph{object counting} and others.

Images in \ebimage\ are stored in the S4 classes \Rclass{Image2D} and
\Rclass{Image3D}, which are directly derived from \R\ arrays.
%FIXME correct this after possible class renaming
Their representation in memory is distinct from that of \magick, and
when functions from \magick\ are called, the image data needs to be
copied and reformatted. This has a number of advantages which offset
the small performance loss that comes with it: The 'native'
arithmetics and computational infrastructure of \R\ can directly be
used on images as it can be on vectors and arrays, and it allows
flexibility to add further image processing and analysis functionality
from other software sources.

%--------------------------------------------------
\section{System Requirements}
%--------------------------------------------------
\ebimage\ like any image processing software is memory and CPU
intensive. There are no formal limitations on system parameters, but
it works with unpacked images, therefore sufficient memory is required
to keep and process them. \R\ is a functional language with mostly
pass-by-value semantics, and the evaluation of expressions can involve
the creation of multiple temporary copies of the objects in the
expression. For example, a single greyscale image of 800x600 pixels
stored as double precision floating point numbers needs about 3.8Mb of
memory just to store it, and twice as much is needed to load it
because there are two copies of the same unpacked image during
loading, saving and displaying.

\ebimage\ is developed in a Linux development environment, and both
32-bit and 64-bit platforms are supported. Versions on other platforms
are available, but may not have been so extensively tested. In the
case of questions or suggestions, we appreciate your user feedback!

Installation of \ebimage\ requires that \magick\ and {\it Magick++}
are installed on the system together with the C/C++ header files (what
is called the xxx-devel packages on many Linux
distributions). Additional requirements include POSIX threads and
Standard Template Library (STL), which are normally parts of any
standard Linux installation.

<<>>=
library("EBImage")
@

%--------------------------------------------------
\section{Data Structures and Image I/O}
%--------------------------------------------------
Images in \ebimage\ are stored in objects of class \image\ for 2D
images and \code{Image3D} for image stacks (like TIFF files) or 3D
images. \image\ class is derived directly from \R\ \code{array}, thus
it supports all operations that are defined for arrays. Most of
standard operations for arrays were redefined in a way that the result
of the operation is again \image. In particular, this inheritance
ensures that subscript operations applied to images are similarly
efficient as those for native R \code{array}s. Several additional
methods are defined to enable image IO,
color mode conversions, data normalization etc.

Information about the color mode of the image can be accessed via its slot \code{rgb}.

It is recommended to the use methods defined for \image\ to operate
with image data, however using the inherited slot \code{.Data} will
give a direct access to the data of an \image\ object.

Image data are stored as double values that should be normalized to
the range [0..1] for grayscale or binary images. Colored (RGB) images
are stored as integer values, in byte-per-color representation. The
highest byte must always be kept 0 in order to enable correct opacity
transformations between \R\ and \magick. Whereas many arithmetic
operations (such as multiplication, subtraction, logarithm, ...) are
immediately meaningful on grayscale images, for RGB images they will
usually not make sense, and care needs to be taken to apply such
operations, for example, separately, color by color.

\ebimage\ can read image both from local files and on remote
servers. Protocols supported include FTP, HTTP and others supported
by \magick.

The \ebimage\ function \code{ping.image} provides an easy way to find out
about attributes of images to be loaded without actually loading them:

<<>>=
server = "http://www.ebi.ac.uk"
file = "/~osklyar/projects/EBImage/examples/example.tif"
# ping.image(paste(server, file, sep=""))
## FIXME: why is this commented out? Can you use the 'eval' options etc. of Sweave instead?
@

Images can be loaded with \code{read.image}. The function
automatically discovers the image type for every file in the
\code{files} argument, calculates the total number of images and returns an
\image\ or \code{Image3D} object as result. By default, 
\code{read.image} converts all images to grayscale. 
For instance, 

<<>>=
im = read.image(paste(server, file, sep=""))
im[1:5,1:5,1:2]
@

and the same image loaded as RGB, 

<<>>=
imRGB = read.image(paste(server, file, sep=""), rgb = TRUE)
imRGB[1:5,1:5,1:2]
@

Images can be saved using \code{write.image} function. If
the source image is of class \code{Image3D}, the number of files
specified can be either one, if the target format supports image stacks,
or it must be the same as the number of images. For example, to
save a small section of the image (printed above) into a single TIFF
file, 

<<>>=
write.image(im[1:5,1:5,1:2], "testOutput.tif")
@
<<echo=false>>=
dir(pattern=".tif")
@

Alternatively, to save two images into separate JPG files

<<>>=
outputFiles = c("testOutput01.jpg", "testOutput02.jpg")
write.image(im[1:5,1:5,1:2], outputFiles)
@
<<echo=false>>=
dir(pattern=".jpg")
@

The output file format is automatically adjusted depending on whether
the image is RGB or grayscale. 

%--------------------------------------------------
\section{Simple Image Data Manipulation and Image Arithmetics}
%--------------------------------------------------
As indicated in the previous section, \image\ and \code{Image3D}
support all operations defined for arrays. The object \code{im} that
was created in the previous section contains 9 images, but for
demonstration purposes we only want to work with one of them, the third one, which shows
cell nuclei. One can obtain the \image\ of interest from an
\code{Image3D} in the same manner as one subscripts arrays

<<>>=
im1 = im[,,3]
@
<<echo=false,results=hide>>=
write.image(im[,,3], "testCells-gray.png")
@
\includegraphics[width=90mm]{testCells-gray.png}

We can determine the range of the image values
% FIXME: I really think this function should be called 'range' and not 'minMax'...
% Also, it is inelegant (although perfectly permissible) to use the name of a function from 'base' as a variable name
<<range,print=TRUE>>=
range = minMax(im1)
treshold = (range[2] + range[1]) / 2
@

A simple tresholding can be done by the usual R array subscript operators
<<>>=
im2 = im1
im2[im2 < treshold] = 0
im2[im2 >= treshold] = 0.99
@

% FIXME
% "there is a know bug that inverts binary images if they are defined with 0 and 1 only"
% what is this bug? can we either fix it, or document it as a feature?

<<echo=false,results=hide>>=
write.image(im2, "simpleTreshold.png")
@
\includegraphics[width=90mm]{simpleTreshold.png}

In a similar manner an images can be cropped. Suppose we only need a
central part of \code{im1} of the size 200x200

<<>>=
im2 = im1[51:250, 51:250]
@
<<echo=false,results=hide>>=
write.image(im2, "imageCrop.png")
@
\includegraphics[width=60mm]{imageCrop.png}

...
\emph{to be continued...}

%--------------------------------------------------
\section{Simple Image Data Manipulation and Image Arithmetics}
%--------------------------------------------------

% Do you really want to direct people to your homepage for this? I
% would find it more straightforward and conventional if the most up-to-date 
% package and documentation were always in the devel-branch of Bioconductor.
% Imagine everybody in the R/bioc world would do this... what a mess...

This vignette is under development. Please check the package web page
for updates of the manual:
http://www.ebi.ac.uk/\~osklyar/projects/EBImage.

\end{document}


