%\VignetteIndexEntry{EBImage image processing}
%\VignetteDepends{}
%\VignetteKeywords{image processing}
%\VignettePackage{EBImage}


\documentclass[11pt]{article}
\usepackage{color}
\definecolor{darkblue}{rgb}{0.0,0.0,0.75}
\usepackage[%
baseurl={http://www.ebi.ac.uk/~osklyar/projects/EBImage/},%
pdftitle={EBImage - Image Processing Toolkit For R},%
pdfauthor={Oleg Sklyar},%
pdfsubject={EBImage},%
pdfkeywords={image processing},%
pagebackref,bookmarks,colorlinks,linkcolor=darkblue,citecolor=darkblue,%
pagecolor=darkblue,raiselinks,plainpages,pdftex]{hyperref}

\newcommand{\code}[1]{{\tt #1}}
\newcommand{\func}[1]{{\it #1}}
\newcommand{\file}[1]{{\tt #1}}
\newcommand{\pack}[1]{{\it #1}}

\newcommand{\ebimage}{{\it EBImage}}
\newcommand{\magick}{{\it ImageMagick}}
\newcommand{\R}{{\it R}}
\newcommand{\image}{{\tt Image2D}}

\begin{document}

%------------------------------------------------------------
\title{EBImage - Image Processing Toolkit For R}
%------------------------------------------------------------
\author{Oleg Sklyar}
\maketitle

%--------------------------------------------------
\section{Foreword}
%--------------------------------------------------
\ebimage\ is an image processing and manipulation package for \R. The core of \ebimage\ is based on \magick\ C++ library (\pack{Magick++}), which provides all I/O operations as well as some filter routines. On top of \magick\ further routines and algorithms are implemented to support \emph{distance maps}, object counting and other algorithms.

At the same time \ebimage\ is not a wrapper for \magick. First, in contrast to \magick\ its purpose is to enable straightforward way to manipulate and analyse large image datasets. Images are represented as \R\ objects that are directly derived from \R\ arrays. This on one hand enables flexibility in data manipulation and analysis and on the other provides a way to apply different image processing routines to the data. Second, \ebimage\ does not cover all the routines of \magick\ and is limited to those that are essential and usefull for data analysis. In this way, it is not intended for image enhancing, restoration and similar. Furthermore, further in the development many \magick\ routines will be substituted with native C++ code working directly with \R\ data structures to reduce performance losses that occur during conversions between \R\ and \magick\ data structures.

%--------------------------------------------------
\section{System Requirements and Installation}
%--------------------------------------------------
\ebimage\ as any image processing software is memory and CPU intensive. There are no formal limitations on system parameters, but it works with unpacked images, therefore sufficient memory is required to keep and process them. Some operations in \ebimage\ require copies of loaded image to be produced and \R\ in addition automatically creates copies of its objects during function calls etc. As an example for memory usage, a single image of 800x600 pixel will need about 3.8Mb of memory just to store it and double as much will be needed to load it because there are two copies of the same unpacked image during loading, saving and displaying.

At the current developmen stage \ebimage\ was designed and tested on Linux and Unix machines only. Both 32-bit and 64-bit platforms are supported. Installation of \ebimage\ requires that development versions of \magick\ and {\it Magick++} are installed on the system. Additional requirements include POSIX threads and Standard Template Library (STL), which are normally a part of any standard Linux installation. Provided the above libraries are present, \ebimage\ can be installed as any other \R\ package by issuing
\\
\\
\file{R CMD INSTALL EBImage}
\\
\\
After installing \ebimage\ and starting \R, the package can be loaded by issuing

<<>>=
library("EBImage")
@

%--------------------------------------------------
\section{Data Structures and Image I/O}
%--------------------------------------------------
Images in \ebimage\ are stored in objects of class \image\ for single 2D images and \code{Image3D} for image stacks (like TIFF files) or 3D images. \image\ class is directly derived from \R\ \code{array} class, thus it supports all operations that are defined for arrays. Most of standard operations were redefined in a way that the result of the operation is again \image. This inheritance also ensures that subscript operations applied to images are optimized for performance because those for \code{array} class are implemented in native C. Several additional methods are defined for \image\ over \code{array} to enable image IO, color mode conversions, data normalization etc.

Information about the color mode of the image can be accessed via its slot \code{rgb}.

It is advisable to use methods defined for \image\ to operate with image data, however using the inherited slot \code{.Data} will give direct access to the array.

Image data are stored as double values that should be normalized to the range [0..1] for grayscale or binary images. Colored (RGB) images are stored as signed integer values, in byte-per-color representation. The highest byte must always be kept 0 in order to enable correct opacity transformations between \R\ and \magick. Whereas all mathematical operations are perfectly correct on grayscale images, RGB data is meaningless for many such operations. In some cases arithmetic operations of + and - are useful though also for RGB images as well.

\ebimage\ can work with both locally stored images and those located on remote servers. Protocols supported include FTP, HTTP and all other supported by \magick.

\ebimage\ command \code{ping.image} provides an easy way to find out about attributes of images to be loaded without actually loading them:

<<>>=
server = "http://www.ebi.ac.uk"
file = "/~osklyar/projects/EBImage/examples/example.tif"
ping.image(paste(server, file, sep=""))
@

Images can be loaded with \code{read.image}. The function automatically discovers image types for every individual file in the \code{files} argument, calculates number of images and returns an \image\ or \code{Image3D} object as result. \ebimage\ is mainly designed to work with grayscale images, therefore, if not specified otherwise \code{read.image} converts all data to grayscale on load. For instance, an example image from \ebimage\ examples can be loaded from the web by issuing

<<>>=
# server = "http://www.ebi.ac.uk"
# file = "/~osklyar/projects/EBImage/examples/example.tif"
im = read.image(paste(server, file, sep=""))
im[1:5,1:5,1:2]
@

If the same image is loaded as RGB, the following output will be generated

<<>>=
im = read.image(paste(server, file, sep=""), rgb = TRUE)
im[1:5,1:5,1:2]
@

Images can be saved using \code{write.image} function of \ebimage. If the source image is of class \code{Image3D}, the number of files specified can be either one if the target format supports image stacks or must exactly correspond to the number of images. For example, to save a small section of the image (printed above) into a single TIFF file, one needs to issue

<<>>=
write.image(im[1:5,1:5,1:2], "testOutput.tif")
# write control
dir(pattern=".tif")
@

Alternatively, to save two images into separate JPG (or any other format) files

<<>>=
outputFiles = c("testOutput01.jpg", "testOutput02.jpg")
write.image(im[1:5,1:5,1:2], outputFiles)
# write control
dir(pattern=".jpg")
@

There is no difference if the original imahe is RGB or grayscale, output file format is automatically adjusted.

%--------------------------------------------------
\section{Simple Image Data Manipulation and Image Arithmetics}
%--------------------------------------------------



\end{document}


